# Manipulation
library(dplyr)
library(tidyverse)
library(caTools)
library(lubridate)
# Visualization
library(ggplot2)
library(plotly)
library(ggthemes)
library(corrplot)
library(ggcorrplot)
library(ggstatsplot)
library(ggpubr)
# EDA REPORT
library(dlookr)
library(visdat)
library(DataExplorer)
library(SmartEDA)
library(flextable)
library(ISLR)
# Machine Learning
library(missRanger)
library(rpart)
library(randomForest)
library(Amelia)
library(psych)
library(caret)
library(Hmisc)
# Importer les donnée qui ont dans le fichier Omrane.csv qui est dans la même répertoire
data <- read.csv(file = "./Omrane.csv", header = TRUE, sep="\t", dec=",")
# deleting the columns that we don't need in our analysis
data = select(data, c(-"N..Lot",-"TitreFoncier",-"CIN.RC",-"DateDeCréation"))
colnames(data)[16] <- "DésignationTypeDeDocument"
# generer une liste des indexes aléatoires
shuffle_index <- sample(1:nrow(data))
# On va utiliser ses indexes pour mélanger les donnée
data <- data[shuffle_index, ]
glimpse(data)
#fixing the column type
cols.num <- c("NombreUnité","StatutADV", "Superficie", "PrixUnitaire", "PrixTotal", "Vers1", "Vers2", "Vers3", "TotalVersement",
"VersRegularis","TropPerçuRéglé", "TropPerçuNonRéglé", "ResteàPayer", "TotalAvances")
cols.char = c("NuméroClient")
cols.date = c("DateLivraison","DateContrat","DateDeCréation")
data[cols.num] <- sapply(data[cols.num],as.numeric)
data[cols.char] <- sapply(data[cols.char],as.character)
data$Création <- ymd(data$Création)
data$DateContrat <- ymd(data$DateContrat)
data$DateLivraison <- ymd(data$DateLivraison)
sapply(data, class)
# Les valeurs non-observés pour chaque attribut
data %>% plot_missing()
# since the two columns DateContrat and DateLivraison are 100% missing and the company can't provide a new dataset that fix the problem of the missing Feautures unless they are very important and less than 50% in the case we could use them in Analysis in our case the mentioned variables should be dropped
plot_na_pareto(data, only_na = TRUE)
ggplotly(plot_na_pareto(data,  only_na = TRUE))
# the problem with pareto chart is that we don't know whether the missing values in different columns belong to the same row of observations
# so visualize the missing values across columns
plot_na_intersect(data)
#vis_miss(data) %>% ggplotly()
#to reduce bias we remove the two variables
data = select(data, c(-"DateLivraison",-"DateContrat"))
# to impute the numeric continueous missing values & outliers we're going to use machine learning algorithms :
# rpart - Recursive Partitioning and Regression Trees.
# mice - Multivariate Imputation by Chained Equations
# mean
# dlookr imputation
#set.seed(123)
#data_na <- generateNA(data) %>% mutate(Designation = factor(Designation))
#plot_na_intersect(data_na, only_na = TRUE)
#
#imputate_na(data_na, Création, StatutADV, method = "mean") %>%
#  plot()
#imputate_na(data_na, Création, StatutADV, method = "rpart") %>% plot()
#imputate_na(data_na, Création, StatutADV, method = "mice", seed = 111) %>% plot()
#
#Miss Ranger Imputation
#data_imputed <- missRanger(data_na, formula = . ~ ., num.trees = 1000, seed = 3)
dummy.data.frame(data)
install.packages("dummies")
library(dummies)
data.segmentation = dummy.data.frame(data)
View(data.segmentation)
write.csv(data.segmentation)
View(data)
View(data)
distances = dist(data[17:26], method ="euclidean")
#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
dataml <- read.csv(file = "./data-ml.csv", header = TRUE, row.names = 1)
max(dataml$PrixUnitaire)
dataml$Description
distinct(dataml,Description)
library(distinct)
library(dplyr)
distinct(dataml,Description)
library(shiny); runApp('Omrane-ML.R')
distinct(dataml$Description)
distinct(dataml$Description)
c(distinct(dataml,Description))
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
c(distinct(dataml,Description))
runApp('Omrane-ML.R')
d = c(distinct(dataml,Description))
View(d)
d = list(distinct(dataml,Description))
# Define UI for application that draws a histogram
ui <- fluidPage(
# Application title
titlePanel("Omrane Products Price Predictions"),
# Sidebar with a slider input for number of bins
sidebarLayout(
sidebarPanel(
sliderInput("bins",
"Prix unitaire:",
min = min(dataml$PrixUnitaire),
max = max(dataml$PrixUnitaire),
value = 100,
step=100),
checkboxGroupInput(
"Region",
"Choisir une region",
choices = ,
selected = NULL,
inline = FALSE,
width = NULL,
choiceNames = NULL,
choiceValues = NULL
)
),
textOutput("result")
# Show a plot of the generated distribution
#mainPanel(
#   plotOutput("distPlot")
#)
)
)
rm(d)
d = list(distinct(dataml,Description))
View(d)
runApp('Omrane-ML.R')
view(d)
regionsValues = c(distinct(dataml,Description))
regionsKeys = c(distinct(dataml,Description))
regionsList = setNames(as.list(regionsKeys),regionsValues)
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
"Exponential" = "exp")
regionsList
regions = distinct(dataml,Description)
# Define UI for application that draws a histogram
ui <- fluidPage(
# Application title
titlePanel("Omrane Products Price Predictions"),
# Sidebar with a slider input for number of bins
sidebarLayout(
sidebarPanel(
sliderInput("bins",
"Prix unitaire:",
min = min(dataml$PrixUnitaire),
max = max(dataml$PrixUnitaire),
value = 100,
step=100),
checkboxGroupInput(
"Region",
"Choisir une region",
choices =  regions,
selected = NULL,
inline = FALSE,
width = NULL,
choiceNames = NULL,
choiceValues = NULL
)
),
textOutput("result")
# Show a plot of the generated distribution
#mainPanel(
#   plotOutput("distPlot")
#)
)
)
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
regions
#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
dataml <- read.csv(file = "./data-ml.csv", header = TRUE, row.names = 1)
regions = distinct(dataml,Description)
View(regions)
sapply(regions,class)
regions = c(distinct(dataml,Description))
View(regions)
sapply(regions,class)
regions
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
typeUnite = c(distinct(dataml, TypeUnité))
typeUnite
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
library(shiny)
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
#
# This is a Shiny web application. You can run the application by clicking
# the 'Run App' button above.
#
# Find out more about building applications with Shiny here:
#
#    http://shiny.rstudio.com/
#
dataml <- read.csv(file = "./data-ml.csv", header = TRUE, row.names = 1)
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
View(dataml)
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
dataml <- read.csv(file = "./data-ml.csv", header = TRUE, row.names = 1)
regions = c(distinct(dataml,Description))
designation = distinct(dataml,Designation)
typesUnite = c(distinct(dataml,TypeUnité))
typesProduit = c(distinct(dataml,TypeProduit))
library(dplyr)
dataml <- read.csv(file = "./data-ml.csv", header = TRUE, row.names = 1)
regions = c(distinct(dataml,Description))
designation = distinct(dataml,Designation)
typesUnite = c(distinct(dataml,TypeUnité))
typesProduit = c(distinct(dataml,TypeProduit))
model <- randomForest(PrixTotal ~ ., data = dataml, ntree = 500, mtry = 4, importance = TRUE)
print(model)
library(randomForest)
model <- randomForest(PrixTotal ~ ., data = dataml, ntree = 500, mtry = 4, importance = TRUE)
print(model)
View(dataml)
which.min(model$mse)
model <- randomForest(PrixTotal ~ ., data = dataml, ntree = 8, mtry = 4, importance = TRUE)
which.min(model$mse)
print(model)
model <- randomForest(PrixTotal ~ ., data = dataml, ntree = 500, mtry = 4, importance = TRUE)
which.min(model$mse)
print(model)
conf = model$confusion
conf
library(shiny); runApp('Omrane-ML.R')
library(shiny)
library(shinythemes)
library(dplyr)
library(randomForest)
library(shinythemes)
runApp('Omrane-ML.R')
print(Output)
datasetInput <- reactive({
# outlook,temperature,humidity,windy,play
df <- data.frame(
Name = c("Region",
"typeUnite",
"typeProduit",
"Superficie"),
Value = as.character(c(input$Region,
input$typeUnite,
input$typeProduit,
input$Superficie)),
stringsAsFactors = FALSE)
PrixTotal <- "PrixTotal"
df <- rbind(df, PrixTotal)
input <- transpose(df)
write.table(input,"input.csv", sep=",", quote = FALSE, row.names = FALSE, col.names = FALSE)
test <- read.csv(paste("input", ".csv", sep=""), header = TRUE)
#test$outlook <- factor(test$outlook, levels = c("overcast", "rainy", "sunny"))
Output <- data.frame(Prediction=predict(model,test), round(predict(model,test,type="prob"), 3))
print(Output)
})
set.seed(100)
train <- sample(nrow(data1), 0.7*nrow(data1), replace = FALSE)
TrainSet <- data1[train,]
set.seed(100)
train <- sample(nrow(dataml), 0.7*nrow(dataml), replace = FALSE)
TrainSet <- dataml[train,]
View(TrainSet)
model <- randomForest(PrixTotal ~ ., data = TrainSet, ntree = 500, mtry = 4, importance = TRUE)
print(model)
model <- randomForest(PrixTotal ~ ., data = TrainSet, ntree = 500, mtry = 8, importance = TRUE)
model <- randomForest(PrixTotal ~ ., data = TrainSet, ntree = 500, mtry = 4, importance = TRUE)
predTrain <- predict(model, TrainSet)
table(predTrain, TrainSet$Condition)
table(predTrain, TrainSet$PrixTotal)
runApp('Omrane-ML.R')
runApp('Omrane-ML.R')
sk
clear
